#!/usr/bin/env bash
set -euo pipefail

# Echoerr  if [ "$QUIET" -ne 1 ]; then printf "%s\n" "$*" 1>&2; fi
# TODO Document modularization
# TODO Use stderr for errors
# TODO git repo README?
# TODO Turn arguments into string instead of array?
# TODO Daily notes [daily] (alias: d|today)
# TODO todo.txt integration "jot t[odo] <args>"

# "STYLE" GUIDE and other best practices
# Always use exactly ("${@:-}") when taking arguments in a function so you can properly iterate over the array with "${arr[@]}"
#  -z "${var// }"                  - var is nothing or whitespace
#  -z "${var+x}"                   - var is unset
#  -z "${var}" -a "${var+x}" = "x" - var is set but empty
#  "${#arr}"                       - get length of array, even empty items
#  -z "${arr[*]// }"               - array contains nothing or whitespace-items
# Global variables are in CAPITALIZED_SNAKE_CASE
# Local variables are prefixed by an underscore and in _snake_case, they are initialized with the 'local' keyword.
# This script is *not* posix compliant, and has to be run in bash (hence the bang), [[]] is acceptable but [] is preferred.

# Variables - change these in the config (~/.config/jot/jotrc) {{{
# Booleans in this script are set to nothing or an empty string for false, and anything for true.

: "${CONFIG_DIR:=$(realpath ${XDG_CONFIG_HOME:-${HOME}/.config}/jot)}" # The base path for your config file(s)
: "${CONFIG:=${CONFIG_DIR}/jotrc}" # Your config file
: "${MODULE_DIR:=${CONFIG_DIR}/d}" # Where your sub-commands / modules are stored
: "${AUCONF:=${CONFIG_DIR}/.auconf}" # Automatically generated config
: "${JOT_DIR=$(realpath ${HOME}/notes)}" # Where your notes will be stored
: "${JOT_EXTENSION:=.md}" # The extension for your notes
: "${EDITOR:=vim}" # The editor you want to use
: "${DEFAULT_ACTION:=ls}" # The default action to perform
: "${SHOW_HIDDEN:=}" # unset / '' = false ; anything = true
: "${INTERACTIVE:=}" # unset / '' = false ; anything = true
test -z "${USE_COLOUR+x}" && USE_COLOUR="true" # Set USE_COLOUR to "" to not use coloured output, if USE_COLOUR is unset (not zero), set to true.
declare -A ALIASES=( ["ls"]="list" ["e"]="edit" ["dir"]="mkdir" ["new"]="add" )
#: "${SYNC_SERVICE:=}" # TODO Sync when open/close/watch?

#LASTFILE="${LASTFILE:-}"
#if test "${REMEMBER_LAST}" = "yes" -a "${1}" != "."; then
#  NOTES_DIR="${LAST_DIR:-${NOTES_DIR}}"
#else
#  LASTFILE=""
#fi
#NOTES_DIR="$(realpath "${NOTES_DIR}")"

colours () { # {{{
  RESET="${USE_COLOUR:+$'\e[0;39m'}"

  E_BOLD="${USE_COLOUR:+$'\e[1m'}"
  E_DIM="${USE_COLOUR:+$'\e[2m'}"
  E_UNDERLINE="${USE_COLOUR:+$'\e[4m'}"
  E_BLINK="${USE_COLOUR:+$'\e[5m'}"
  E_INVERT="${USE_COLOUR:+$'\e[7m'}"
  E_HIDDEN="${USE_COLOUR:+$'\e[8m'}"

  R_NORMAL="${USE_COLOUR:+$'\e[0m'}"
  R_BOLD="${USE_COLOUR:+$'\e[21m'}"
  R_DIM="${USE_COLOUR:+$'\e[22m'}"
  R_UNDERLINE="${USE_COLOUR:+$'\e[24m'}"
  R_BLINK="${USE_COLOUR:+$'\e[25m'}"
  R_INVERT="${USE_COLOUR:+$'\e[27m'}"
  R_HIDDEN="${USE_COLOUR:+$'\e[28m'}"

  C_DEFAULT="${USE_COLOUR:+$'\e[19m'}"
  C_BLACK="${USE_COLOUR:+$'\e[30m'}"
  C_RED="${USE_COLOUR:+$'\e[31m'}"
  C_GREEN="${USE_COLOUR:+$'\e[32m'}"
  C_BLUE="${USE_COLOUR:+$'\e[34m'}"
  C_MAGENTA="${USE_COLOUR:+$'\e[35m'}"
  C_LGRAY="${USE_COLOUR:+$'\e[37m'}"
  C_GRAY="${USE_COLOUR:+$'\e[90m'}"
  C_LRED="${USE_COLOUR:+$'\e[91m'}"
  C_LGREEN="${USE_COLOUR:+$'\e[92m'}"
  C_LYELLOW="${USE_COLOUR:+$'\e[93m'}"
  C_LBLUE="${USE_COLOUR:+$'\e[94m'}"
  C_LMAGENTA="${USE_COLOUR:+$'\e[95m'}"
  C_LCYAN="${USE_COLOUR:+$'\e[96m'}"
  C_WHITE="${USE_COLOUR:+$'\e[97m'}"

  B_DEFAULT="${USE_COLOUR:+$'\e[49m'}"
  B_BLACK="${USE_COLOUR:+$'\e[40m'}"
  B_RED="${USE_COLOUR:+$'\e[41m'}"
  B_GREEN="${USE_COLOUR:+$'\e[42m'}"
  B_YELLOW="${USE_COLOUR:+$'\e[43m'}"
  B_BLUE="${USE_COLOUR:+$'\e[44m'}"
  B_MAGENTA="${USE_COLOUR:+$'\e[45m'}"
  B_CYAN="${USE_COLOUR:+$'\e[46m'}"
  B_LGRAY="${USE_COLOUR:+$'\e[47m'}"
  B_GRAY="${USE_COLOUR:+$'\e[100m'}"
  B_LRED="${USE_COLOUR:+$'\e[101m'}"
  B_LGREEN="${USE_COLOUR:+$'\e[102m'}"
  B_LYELLOW="${USE_COLOUR:+$'\e[103m'}"
  B_LBLUE="${USE_COLOUR:+$'\e[104m'}"
  B_LMAGENTA="${USE_COLOUR:+$'\e[105m'}"
  B_LCYAN="${USE_COLOUR:+$'\e[106m'}"
  B_WHITE="${USE_COLOUR:+$'\e[106m'}"
} # }}}
colours
# }}}

usage () { # {{{
  # TODO Automatically call the usage function of each module
  # TODO Automatic Command detection and help menu
  SCRIPTNAME="$(basename $(realpath ${0}))"
	cat <<-EOMAN
	${RESET}${C_GREEN}Usage:${RESET} ${E_BOLD}${SCRIPTNAME}${RESET}  <${C_RED}options${RESET}>  <${C_GRAY}[${C_BLUE}command ${C_GRAY}|| ${C_BLUE}module${C_GRAY}] ${C_MAGENTA}arguments${RESET}>
	
	${C_GREEN}Options:${RESET}
	  -h, --help                 Display usage menu. Use twice for more information.
	
	${C_GREEN}Built-in commands:${RESET}
	  add             ${C_GRAY}<${C_RED}name${RESET}${C_LYELLOW}?${C_GRAY}>${RESET}    Create a new note.
	  list                       List available notes.
	  edit            ${C_GRAY}<${C_RED}name${RESET}${C_LYELLOW}?${C_GRAY}>${RESET}    Edit existing note. Index or name.
	
	${C_GREEN}Examples:${RESET}
	  ${SCRIPTNAME} -h${RESET}
	${RESET}
	EOMAN

  if test "${HELPLEVEL}" -gt "1"; then
		cat <<-EOEXTMAN
		${C_GREEN}Notable variables:${RESET}           ${E_UNDERLINE}current ${C_GRAY}(default | type: available options)${RESET}
		  CONFIG_DIR                 ${CONFIG_DIR} ${C_GRAY}('${XDG_CONFIG_HOME:-${HOME}/.config}/jot' | path)${RESET}
		  CONFIG                     ${CONFIG} ${C_GRAY}('${XDG_CONFIG_HOME:-${HOME}/.config}/jot/.jotrc' | filepath)${RESET}
		  MODULE_DIR                 ${MODULE_DIR} ${C_GRAY}('${XDG_CONFIG_HOME:-${HOME}/.config}/jot/d' | path)${RESET}
		  JOT_DIR                    ${JOT_DIR} ${C_GRAY}('${HOME}/notes' | path)${RESET}
		  JOT_EXTENSION              ${JOT_EXTENSION} ${C_GRAY}('.md' | string)${RESET}
		  USE_COLOUR                 ${USE_COLOUR} ${C_GRAY}('true' | string: 'true' or '')${RESET}
		  EDITOR                     ${EDITOR} ${C_GRAY}('${EDITOR:-vim}' | executable)${RESET}
		  DEFAULT_ACTION             ${DEFAULT_ACTION} ${C_GRAY}('ls' | command-argument)${RESET}
		  ALIASES                    ${!ALIASES[@]} ${C_GRAY}(( ["ls"]="list" ["e"]="edit" ["dir"]="mkdir" ) | associative array)${RESET}
		  SHOW_HIDDEN                ${SHOW_HIDDEN} ${C_GRAY}('' | string: 'true' or '')${RESET}
		
		Jot is an alternative to todotxt/todo.txt-cli primarily focused on quick note taking and hackability.
		The config can be found at ${CONFIG}, and the modules are located at ${MODULE_DIR}.
		To see usage of the default modules, run '${SCRIPTNAME} <module> usage'.
		${RESET}
		EOEXTMAN
  for cmd in "${COMMANDS[@]}"; do
  # TODO Also add user commands
    printf "${C_BLUE}${B_BLUE}|${RESET} ${B_BLUE}${C_BLUE}[${C_BLACK}${cmd}${C_BLUE}]${RESET}\n"
    "c:${cmd}" usage | sed -e "s/^/${C_BLUE}${B_BLUE}|${RESET} /"
    printf "\n"
  done
  fi
} # }}}

# Argument parsing {{{
# Handle incoming arguments {{{
positional=()
HELPLEVEL=0
while test "${#}" -gt "0"; do
  case "${1}" in
    -h|--help) # {{{
      ((HELPLEVEL+=1))
      shift;; # }}}
    -c|--config) # {{{
      _config="${2}"
      # TODO Should this be handled when the variable is set? e.g. CONFIG='' And not just on --config?
      if test -f "${_config}"; then
        CONFIG="${_config}"
      elif test -f "${CONFIG_DIR}/${_config}"; then
        CONFIG="${CONFIG_DIR}/${_config}"
      else
        printf "Provided config '${_config}' doesn't exist... continue?\n"
        exit 0
        # TODO Check for yes/no prompt
      fi
      shift;shift;; # }}}
    --cd|--config-dir) # {{{
      _config_dir="${2}"
      if test -d "${_config_dir}"; then
        CONFIG_DIR="${_config_dir}"
      fi
      shift;shift;; # }}}
    --no-colour|--no-color) # {{{
      USE_COLOUR=""
      colours
      shift;; # }}}
    -s|--hidden) # {{{
      SHOW_HIDDEN="true"
      shift;; # }}}
    -u|--no-fzf) # {{{
      # TODO Rename to INTERACTIVE?
      USE_FZF=""
      shift;; # }}}
    --*) # {{{
      printf "Unknown option: ${1}\n"
      exit 1
      shift;;
    -*)
      shopts="${1}"
      if test "${#shopts}" -le "2"; then
        printf "Unknown option: ${shopts}\n"
        exit 2
      fi
      shift
      set -- "${shopts:0:2}" "-${shopts:2}" "${@}"
      ;;
    *)
      positional+=("${1}")
      shift;; # }}}
  esac
done
# }}}

# Restore positional arguments {{{
set -- "${positional[@]}"
COMMAND="${1:-${DEFAULT_ACTION:?No command provided}}"
test -n "${1+x}" && shift
# NOTE $ARGS is the exact same as $@
ARGS=("${@:-}")
# }}}
# }}}

# Load user configuration {{{
# TODO Consider removing allexport and just use export in config instead
# TODO Move this to after parsing incoming arguments, --config should be allowed
# TODO Ask to create config? Or just make it when saving last path. Should last path be saved in a separate auto-gen config?
set -o allexport
test -f "${AUCONF}" && source "${AUCONF}"
test -f "${CONFIG}" && source "${CONFIG}"
set +o allexport
# }}}

# Commands {{{
# NOTE Function prefixes
#      c: command
#      u: utility
COMMANDS=("add" "list" "edit")

u:get_notes () { # {{{
  \ls -Fh1${SHOW_HIDDEN:+A} ${USE_COLOUR:+--color} "${JOT_DIR}"
} # }}}

c:add () { # {{{
  usage () { # {{{
		cat <<-EOMAN
		Add a note. The file extension will be determined based on the provided name.
		"note.txt" > "note.txt"
		"note."    > "note"
		"note"     > "note${JOT_EXTENSION}"
		
		Typical usage:
		c:add "note"
		
		@param \$1 (optional): The name of the note to create.
		      If this is not provided, the user will be prompted to provide one interactively.
		EOMAN
  }; test "${1:-}" = "usage" && usage && return 0 # }}}
  # !!! Use ("${@:-}") instead of "${@-}" to get an array of all values
  local _args=("${@:-}")
  local _jot=""
  if test ! -z "${_args[*]// }"; then
    _jot="${_args[*]}"
  else
    printf "Note name: "
    read _jot
  fi

  # TODO Make this a function get_note_name() and use date for default
  #if [[ "${NOTE_NAME}" =~ ^\..*$ ]]; then
  if test -z "${_jot// }"; then # Zero or whitespace, TODO Call c:daily() instead
    _jot="$(date +"jot-%a-%Y-%m-%dT%T%z")"
  elif [[ "${_jot}" == .* ]]; then # Starts with a period -> Error
    printf "Invalid note name: '${_jot}'\n"
    exit 1
  elif [[ "${_jot}" == *. ]]; then # Ends with a period
    _jot="${_jot%?}"
  elif [[ "${_jot}" == *.* ]]; then # Has an extension
    : pass
  else # Regular
    _jot="${_jot}${JOT_EXTENSION}"
  fi

} # }}}

c:list () { # {{{
  usage () { # {{{
		cat <<-EOMAN
		List available notes.
		
		Typical usage:
		c:list
		EOMAN
  }; test "${1:-}" = "usage" && usage && return 0 # }}}
  printf "${C_GREEN}${E_UNDERLINE} NOTES ${RESET}\n"
  # NOTE remove ', ""' to remove excess whitespace
  u:get_notes | awk '{print NR, "", $0}'
} # }}}

c:edit () { # {{{
  usage () { # {{{
    :
  }; test "${1:-}" = "usage" && usage && return 0 # }}}
  local _args=("${@:-}")
  local _jot=""
  if test ! -z "${_args[*]// }"; then
    _jot="${_args[@]}"
  else
    # TODO interacitve
    #if test -z "${INTERACTIVE+x}"; then
      printf "Name/index: "
      read _jot
    #else
    #  u:get_notes | fzf
  fi

  if test -f "${JOT_DIR}/${_jot}"; then
    printf "Note with the name already exists, opening ${EDITOR}...\n"
    c:edit "${JOT_DIR}/${_jot}"
  else
    printf "touch ${JOT_DIR}/${_jot}\n"
    c:edit "${JOT_DIR}/${_jot}"
  fi
  #if test "${REMEMBER_LAST}" = "yes"; then
  #  LASTFILE="${NOTE}"
  #fi

  # TODO Check if is int, then get line no, or get the most matching name
  # TODO Open editor with name if doesn't exist anyways, then user can write if want to save
  # TODO If empty, should still open editor in dir?
  local _jot="$(USE_COLOUR="" u:get_notes | sed "${_jot}q;d")" # | sed 's/^[0-9]\s\s//'
  "${EDITOR:?}" "${JOT_DIR}/${_jot}"
} # }}}

c:mkdir () { # {{{
  usage () { # {{{
    :
  }; test "${1:-}" = "usage" && usage && return 0 # }}}
} # }}}

c:archive () { # {{{
  usage () { # {{{
    :
  }; test "${1:-}" = "usage" && usage && return 0 # }}}
  printf "archiving stuffs\n"
} # }}}
# }}}

# Handle intermediate arguments {{{
if test "${HELPLEVEL}" -gt "0"; then
  usage
  exit 0
fi
# }}}

conf_update_var () { # {{{
# TODO FIX
  # source "${0}"
  local _var="${1:?}"
  local _val="${2:-}"

  if test ! -d "$(realpath "$(dirname "${AUCONF}")")"; then
    mkdir -p "$(realpath "$(dirname "${AUCONF}")")"
  fi
  if test ! -f "${AUCONF}"; then
    touch "${AUCONF}"
  fi

  if test ! -z "${_val// }"; then
    if grep -qE "^${_var}=.*$" "${AUCONF}"; then 
      sed -i "s|^${_var}=.*$|${_var}='${_val}'|" "${AUCONF}"
    else
      echo "${_var}='${_val}'" >> "${AUCONF}"
    fi
  else
    sed -i "/^${_var}=.*$/d" "${AUCONF}"
  fi
} # }}}
finish () { # {{{
  # NOTE AUCONF variables and script-variables have to be named differently,
  #      as AUCONF is sourced and would make updating them challenging.
  conf_update_var "CFG_LAST_FILE" "${LAST_FILE:-}"
  conf_update_var "CFG_LAST_DIR" "${LAST_DIR:-}"
} # }}}
trap finish EXIT

check_deps () { # <dependencies:@string> -> Void {{{
  local _deps=${@}
  local _missing=""
  for _dep in ${_deps}; do
    if ! hash "${_dep}" 2>/dev/null; then
      _missing="${_missing} ${_dep}"
    fi
  done
  if test -n "${_missing}"; then
    printf "Missing required dependencies:${_missing}\n"
    exit 1
  fi
} # }}}
check_deps

prompt () { # {{{
  local _prompt="${1:-}"
  local _default="${2:-yes}"
  test "${_default}" = "yes" \
    && printf "${1} [Y/n]" \
    || printf "${1} [y/N]"
  read -p " " -n 1 -r </dev/tty
  printf "\n"
  case "${_default}${REPLY}" in
    "yes"[Yy]*|"no"[Yy]*) return 0;;
    "yes"[Nn]*|"no"[Nn]*) return 1;;
    "yes"*) return 0;;
    "no"*) return 1;;
    *) echo "hm";;
  esac
} # }}}

check_notes_dir () { # {{{
  if test ! -d "${JOT_DIR}"; then
    if prompt "Notes dir '${JOT_DIR}' doesn't exist, create?" "yes"; then
      mkdir -p "${JOT_DIR}"
    else
      exit 1
    fi
  fi
} # }}}
check_notes_dir

# Check which command to run {{{
# Check if the current command is an alias and update $COMMAND accordingly {{{
if test "${ALIASES[${COMMAND}]+x}"; then
  COMMAND="${ALIASES[${COMMAND}]}"
fi
# }}}

# TODO Add a custom command called 'watch' that always runs (like git sync?)
#       Add on-start and on-finish commands, and commands that run in the background &
# TODO Double check if arrays should have "" around them when passing to scripts n stuff, space will break
if test -f "${MODULE_DIR}/${COMMAND}"; then
  source "${MODULE_DIR}/${COMMAND}" "${ARGS[@]}" # TODO Use ${ARGS} instead of "${ARGS[@]}"
#  # TODO If 1 argument, and INTERACTIVE, show interactive menu of which item to modify
#  #      If 1 argument, and not INTERACTIVE, print output and read user input
#         Interactive with read or interactive with fzf
elif test -n "$(LC_ALL=C type -t "c:${COMMAND}")" -a "$(LC_ALL=C type -t "c:${COMMAND}")" = "function"; then
  "c:${COMMAND}" "${ARGS[@]}"
else
  printf "Unrecognized command or module: '${COMMAND}'\n"
  exit 2
fi
# }}}

exit 0







# Things I've done before that could be useful {{{

#finish () { # {{{
##  source "${0}"
#  if test ! -f "${CONFIG}"; then
#    touch "${CONFIG}"
#  fi
#  if test "${REMEMBER_LAST}" = "yes"; then
#    if test -n "${NOTES_DIR}"; then
#      if grep -qE "^LAST_DIR=.*$" "${CONFIG}"; then 
#        sed -i "s|^LAST_DIR=.*$|LAST_DIR='${NOTES_DIR}'|" "${CONFIG}"
#      else
#        echo "LAST_DIR='${NOTES_DIR}'" >> "${CONFIG}"
#      fi
#    else
#      sed -i '/^LAST_DIR=.*$/d' "${CONFIG}"
#    fi
#    if test -n "${LASTFILE}"; then
#      if grep -qE "^LASTFILE=.*$" "${CONFIG}"; then 
#        sed -i "s|^LASTFILE=.*$|LASTFILE='${LASTFILE}'|" "${CONFIG}"
#      else
#        echo "LASTFILE='${LASTFILE}'" >> "${CONFIG}"
#      fi
#    else
#      sed -i '/^LASTFILE=.*$/d' "${CONFIG}"
#    fi
#  else
#    sed -i '/^LASTFILE=.*$/d' "${CONFIG}"
#    sed -i '/^LAST_DIR=.*$/d' "${CONFIG}"
#  fi
#} # }}}
# No reason to trap before doing anything with the shell
#trap finish EXIT

##[cd]
## Check if script is sourced
##if [[ $_ != $0 ]]; then
##  if test -n "${CHANGEDIR}"; then
##    cd "${CHANGEDIR}"
##    export CHANGEDIR=""
##  fi
##  # Replace current shell (this script, since it's sourced) with a new one with the updated path
##  exec "${SHELL:-bash}"
##fi
#
#
#if test "${SYNC_SERVICE}" = "insync"; then
#  if command -v "insync" >/dev/null 2>&1; then
#    if test -z "$(pidof insync)"; then
#      printf "Insync not running, starting...\n"
#      insync start
#      if test "${?}" -ne "0"; then
#        printf "Failed to start insync"
#        exit 1
#
#      fi
#    fi
#  fi
#fi
#
## TODO Only show files matching pattern (.*\.${JOT_EXTENSION})
#
#make_selection () {
#  NOTES_DIR="${1}"
#  ONLY_NOTES="${2:-}"
#
#  OPTIONS="$(\ls -p "${NOTES_DIR}")"
#  # Add a newline if there are any notes, to avoid empty lines in fzf
#  if test -n "${OPTIONS}"; then
#    #while IFS= read -r option; do
#    #done <<< "${OPTIONS}"
#    OPTIONS="${OPTIONS}\n"
#  fi
#  if test -z "${ONLY_NOTES}"; then
#    OPTIONS="${OPTIONS}..\nNew Note\nNew Folder\nDelete Item"
#  fi
#
#  SELECTED_OPTION="$(printf "${OPTIONS}" | "${FZF_BIN}" --query="${LASTFILE}" --info=hidden)"
#  LASTFILE=""
#}
#
## Note: $DIR is updated in make_selection()
#while true; do
#  make_selection "${NOTES_DIR}"
#  if test "${SELECTED_OPTION}" = "New Note"; then
#    NOTE_NAME="$(set +e; printf '' | "${FZF_BIN}" --print-query --info=hidden --prompt 'New note name: '; set -e)"
#    if test -z "${NOTE_NAME// }"; then
#      printf "Please provide a note name...\n"
#      continue
#    fi
#    if [[ "${NOTE_NAME}" == *. ]]; then
#      NOTE="${NOTE_NAME%?}"
#    elif [[ "${NOTE_NAME}" == *.* ]]; then
#      NOTE="${NOTE_NAME}"
#    else
#      NOTE="${NOTE_NAME}${NOTE_EXTENSION}"
#    fi
#    if test -f "${NOTES_DIR}/${NOTE}"; then
#      printf "Note with the name already exists...\n"
#      continue
#    fi
#    touch "${NOTES_DIR}/${NOTE}"
#    "${EDITOR}" "${NOTES_DIR}/${NOTE}"
#    if test "${REMEMBER_LAST}" = "yes"; then
#      LASTFILE="${NOTE}"
#    fi
#  elif test "${SELECTED_OPTION}" = "New Folder"; then
#    FOLDER_NAME="$(set +e; printf '' | "${FZF_BIN}" --print-query --info=hidden --prompt 'New folder name: '; set -e)"
#    if test -z "${FOLDER_NAME// }"; then
#      printf "Please provide a folder name...\n"
#      continue
#    fi
#    mkdir -p "${NOTES_DIR}/${FOLDER_NAME}"
#    DIR="${NOTES_DIR}/${FOLDER_NAME}"
#    if test "${REMEMBER_LAST}" = "yes"; then
#      LASTFILE=""
#    fi
#  elif test "${SELECTED_OPTION}" = ".."; then
#    DIR="$(dirname "${NOTES_DIR}")"
#    if test "${REMEMBER_LAST}" = "yes"; then
#      LASTFILE=""
#    fi
#    #[cd]#cd "${NOTES_DIR}"
#  elif test -d "${NOTES_DIR}/${SELECTED_OPTION}"; then
#    DIR="${NOTES_DIR}/${SELECTED_OPTION}"
#    if test "${REMEMBER_LAST}" = "yes"; then
#      LASTFILE=""
#    fi
#    #[cd]#cd "${NOTES_DIR}"
#  elif test -f "${NOTES_DIR}/${SELECTED_OPTION}"; then
#    "${EDITOR:-vim}" "${NOTES_DIR}/${SELECTED_OPTION}"
#    if test "${REMEMBER_LAST}" = "yes"; then
#      LASTFILE="${SELECTED_OPTION}"
#    fi
#  elif test "${SELECTED_OPTION}" = "Delete Item"; then
#    make_selection "${NOTES_DIR}" "yes"
#    if test -d "${NOTES_DIR}/${SELECTED_OPTION}" -o -f "${NOTES_DIR}/${SELECTED_OPTION}"; then
#      DELETE_ACCEPT="$(printf "Yes\nNo" | "${FZF_BIN}" --info=hidden --prompt="Delete ${SELECTED_OPTION}? (${NOTES_DIR}/${SELECTED_OPTION})")"
#      if test "${DELETE_ACCEPT}" = "Yes"; then
#        rm -rf "${NOTES_DIR}/${SELECTED_OPTION}"
#      fi
#    fi
#    if test "${REMEMBER_LAST}" = "yes"; then
#      LASTFILE=""
#    fi
#  else
#    printf "Something went wrong...\n"
#    printf "Selected option: ${SELECTED_OPTION}\n"
#    printf "Directory: ${NOTES_DIR}\n"
#    break
#  fi
#done

# yaml frontmatter parsing {{{
#GLOBS=("*.txt" "*.md")
#DIR="$(realpath .)"
##################################################
## This function will parse a simple YAML file
## and will output bash variables.
## YAML frontmatter is also supported.
##
## Typical Usage:
## eval $(parse_yaml sample.yml "PREFIX_")
##
## @param $1: The yaml file to parse
## @param $2: The prefix to append to all of the
##       variables to be created
##################################################
#function parse_yaml {
#   local prefix=$2
#   #local s='[[:space:]]*' w='[a-zA-Z0-9_]*' fs=$(echo @|tr @ '\034')
#   local s='[[:space:]]*' w='[a-zA-Z0-9_\.]*' fs=$(echo @|tr @ '\034') #+ Work with . in variable names
#   #+ Add between first and second line of sed command to avoid injection
#   #-e 's|`||g;s|\$||g;' \
#   sed -ne "s|^\($s\):|\1|" \
#        -e 's|`||g;s|\$||g;' \
#        -e "s|^\($s\)\($w\)$s:$s[\"']\(.*\)[\"']$s\$|\1$fs\2$fs\3|p" \
#        -e "s|^\($s\)\($w\)$s:$s\(.*\)$s\$|\1$fs\2$fs\3|p"  $1 |
#   awk -F$fs '{
#      indent = length($1)/2;
#      vname[indent] = $2;
#      for (i in vname) {if (i > indent) {delete vname[i]}}
#      if (length($3) > 0) {
#         vn=""; for (i=0; i<indent; i++) {vn=(vn)(vname[i])("_")}
#         gsub(/^[ \t]+/, "", $3); gsub(/[ \t]+$/, "", $3); #+ Strip trailing and leading whitespace
#         gsub(/\s*#.*$/, "", $3); #+ Remove comments
#         printf("%s%s%s=\"%s\"\n", "'$prefix'",vn, $2, $3);
#      }
#   }'
#}
#
##YML_type=""
#eval $(parse_yaml asd.md "YML_")
## ---
## type:    any[str, script, sheet] default(sheet)
## aliases: [str]                   default(n/a)
## ---
##echo $YML_type
#
## https://leonid.shevtsov.me/post/find-files-that-have-yaml-frontmatter/
#
#globglogabgalab=""
#i=1
#for glob in "${GLOBS[@]}"; do
#  test "${i}" -lt "${#GLOBS[@]}" \
#    && binder="-o " \
#    || binder=""
#  globglogabgalab="${globglogabgalab}-iname '${glob}' ${binder}"
#  ((i+=1))
#done
#
#echo $globglogabgalab
## -r recursive
## -n line-number
## -w word-regexp
##grep -rn "${DIR}" ${globglogabgalab} -e '---.*---'  # '(?<=yeet).*(?=skote)' 
#find "${DIR}" \
#     -type f \
#     \( ${globglogabgalab} \) \
#     -exec sh -c 'if (head -n 1 "{}" | grep -- --- >/dev/null); then echo "{}"; fi' \;
# }}}
# }}}

