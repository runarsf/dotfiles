#!/usr/bin/env python3
import os
import os.path as op
import re
import sys
import string
import json
import urllib.request
import argparse
import requests
import subprocess
from yaml import safe_load
from jsonschema import validate
from requests.exceptions import RequestException

def is_valid_file(parser, arg):
    if not op.isfile(arg):
        parser.error("The file %s does not exist!" % arg)
    else:
        return open(arg, 'r')  # return an open file handle

parser = argparse.ArgumentParser(description='Download files')
parser.add_argument('group', metavar='GROUP', type=str, nargs='?', help='The group to use', default=None)
#parser.add_argument('-a', '--all', help='Get all the links!',
#                    required=False, dest='all_groups',
#                    action='store_const', const=True, default=False)
parser.add_argument('-c', '--config', help='The yaml configuration file to use.',
                    dest='config', metavar='FILE', type=lambda x: is_valid_file(parser, x),
                    default = op.join(os.environ.get('XDG_CONFIG_HOME', op.join(os.environ.get('HOME', '~'), '.config')), '.succ.yml'))
args = parser.parse_args()
cfg = safe_load(args.config)

# TODO Use default instead of all when no argument?
# TODO schema-hook to validate that groups and handlers n stuff exists
# https://json-schema.org/understanding-json-schema/reference/object.html
# https://medium.com/grammofy/handling-complex-json-schemas-in-python-9eacc04a60cf
# https://python-jsonschema.readthedocs.io/en/stable/_modules/jsonschema/validators/?highlight=minlength
# https://stackoverflow.com/questions/38478406/ensure-one-property-is-not-empty-in-json-schema/38478655
#schema = safe_load("""
#""")
schema = {
    "$schema": "http://json-schema.org/draft-07/schema#",
    "type": "object",
    "definitions": {
        "nonEmptyString": {
            "type": "string",
            "minLength": 1
        }
    },
    "properties": {
        #"version": { "type": "number" },
        #"handlers": {
        #    "type": "object",
        #    "properties": {
        #        "git": { "type": "null" },
        #        "git-bare": { "type": "null" },
        #        "gist": { "type": "null" },
        #        "raw": { "type": "null" },
        #        "git": { "type": "null" }
        #    },
        #    "additionalProperties": { "type": ["string", "array"] }
        #},
        "hooks": {
            "type": "object",
            "additionalProperties": { "type": ["string", "array"] }
        },
        "settings": {
            "type": "object",
            "properties": {
                "default_group": { "type": "string", "$ref": "#/definitions/nonEmptyString" },
                "show_hook_content": { "type": "boolean" }
            },
            "additionalProperties": False
        },
        "collections": {
            "type": "object",
            "additionalProperties": { "type": "array" }
        },
        "groups": {
            "type": "object",
            "additionalProperties": {
                "type": "object",
                "required": [ "files" ],
                "properties": {
                    "path": { "type": "string", "$ref": "#/definitions/nonEmptyString" },
                    "handler": { "type": "string", "$ref": "#/definitions/nonEmptyString" },
                    "hooks": { "type": ["string", "array"] },
                    "files": {
                        "type": "array",
                        "items": {
                            "type": "object",
                            "required": [ "url" ],
                            "properties": {
                                "url": { "type": "string", "$ref": "#/definitions/nonEmptyString" },
                                "path": { "type": "string", "$ref": "#/definitions/nonEmptyString" },
                                "hooks": { "type": [ "string", "array" ] },
                                "pre_hooks": { "type": [ "string", "array" ] },
                                "strategy": { "type": "string", "enum": [ "yes", "no", "overwrite", "skip", "ask" ] }
                            },
                            "additionalProperties": False
                        }
                    }
                }
            }
        }
    },
    "required": [ "groups" ],
    "additionalProperties": False
}
validate(cfg, schema)

def get_filename_from_url(url: str):
    #try:
    with requests.get(url) as r:
        filename = ''
        if "Content-Disposition" in r.headers.keys():
            filename = re.findall("filename=(.+)", r.headers["Content-Disposition"])[0]
        else:
            filename = url.split("/")[-1]
    #except RequestException as e:
    #    raise Exception(e)

def construct_cfg(cfg):
    # groups and files essentially have the same config, so instead of "guessing"
    # where the config is stored, we merge the objects (minus differences (g.files))
    # and assume groups.files.file has the truth. additionally, mergin with a default
    # set of values will let us skip checking if every item exists before using.
    default_settings = {
        "default_group": None,
        "show_hook_content": True
    }
    cfg['settings'] = {**default_settings, **cfg['settings']}

    for group in cfg['groups']:
        default_file_cfg = {
            "strategy": "ask",
            "pre_hooks": [ None ],
            "hooks": [ None ],
            "url": None,
            "path": None
        }
        g = {**default_file_cfg, **cfg['groups'][group].copy()}
        del g['files']

        for i, f in enumerate(cfg['groups'][group]['files']):
            # If nothing is provided in f.path, retrieve filename from headers.
            if 'path' not in f:
                f['path'] = get_filename_from_url(f['url'])

            # Generate absolute path from g.path + f.path.
            if f['path'] and '/' in f['path']:
                f['path'] = op.abspath(op.expanduser(f['path']))
            elif g['path'] and f['path'] and not '/' in f['path']:
                f['path'] = op.abspath(op.join(op.expanduser(g['path']), f['path']))

            f = {**g, **f}

            if f['pre_hooks'] and type(f['pre_hooks']) == str:
                f['pre_hooks'] = [f['pre_hooks']]
            if f['hooks'] and type(f['hooks']) == str:
                f['hooks'] = [f['hooks']]

            cfg['groups'][group]['files'][i] = f

            #print(json.dumps(cfg, indent=2, sort_keys=True))
    return cfg
cfg = construct_cfg(cfg)


def query(question: str, options: list = ['Yes', 'No'], default_choice: int = 1):
    cstring = list(options)
    cstring[default_choice] = f'[{cstring[default_choice]}]'
    cstring = '/'.join(cstring)

    while True:
        sys.stdout.write(f'{question} ({cstring}) ')
        choice = input().lower()
        if not choice:
            return options[default_choice]
        for option in options:
            if choice and choice in option.lower():
                return option
        else:
            sys.stdout.write(f"Please respond with {cstring}\n")

def process_hooks(cfg, hooks: list = None, template_strings: dict = None):
    for hook in hooks:
        try:
            formatted_hook = []
            for hook_part in cfg['hooks'][hook]:
                formatted_hook.append(string.Template(hook_part).safe_substitute(template_strings))
            print('$ ' + ' '.join(formatted_hook))
            #q = query(f'Run hook?', ['Yes', 'No'], 0)
            #if q and q == "Yes":
            try:
                # `text` required python >= 3.7, replacing with `universal_newlines=True` seems to work...
                #hook_call = subprocess.run(formatted_hook, text=True, stdout=subprocess.PIPE, check=True)
                hook_call = subprocess.run(formatted_hook, universal_newlines=True, stdout=subprocess.PIPE, check=True)
                for line in hook_call.stdout.split('\n'):
                    print(f'> {line}')
            except subprocess.CalledProcessError:
                print('Command error, see output...')
        except KeyError:
            pass

def arcanine(cfg: dict, link: dict):
    if op.isfile(link['path']):
        # TODO allow skipping
        # TODO update cfg instead of passing fpath, hooks and prehooks?
        if not link['strategy'] or link['strategy'].lower() == 'ask':
            q = query(f"File '{link['path']}' already exists, overwrite?", ['Yes', 'No'], 1)
            if not q or q == "No":
                return
        elif link['strategy'].lower() in ['overwrite', 'yes']:
            pass
        else: #elif link['strategy'].lower() in ['skip', 'no']:
            return
    print(f'retrieving {link["url"]} > {link["path"]}')
    template_strings = dict(__file=link['path'], __path=os.path.dirname(link['path']), url=link['url'])
    process_hooks(cfg, link['pre_hooks'], template_strings)
    urllib.request.urlretrieve(link['url'], link['path'])
    process_hooks(cfg, link['hooks'], template_strings)

def main(cfg, group: str = None):
    try:
        if not group:
            #try:
            #    if cfg['settings']['default_group'].lower() == 'none': raise KeyError('settings.default_group is None')
            if not cfg['settings']['default_group']:
                print('No group provided.')
                return
            main(cfg, cfg['settings']['default_group'])
            #except KeyError:
            #    print('No group provided.')
            return

        if group not in cfg['groups']:
            print(f'Invalid group \'{group}\'.')
            return
        for link in cfg['groups'][group]['files']:
            arcanine(cfg, link)
            #print(link)
    except KeyboardInterrupt:
        print("\n...ait")

main(cfg, args.group)


