#!/usr/bin/env bash
set -euo pipefail

# TODO: Config file, see: 
# TODO: Help menu

if test -z "${DISPLAY}"; then
  printf "X server doesn't seem to be running....\n"
  exit 1
fi

# Variables {{{
CONFIG="${XDG_CONFIG_HOME:-${HOME}/.config}/.screenshotrc"

# Change these in $CONFIG (~/.config/.screenshotrc)
SCREENSHOT_DIRECTORY="${HOME}/Pictures/Screenshots"
COUNTDOWN="3"

set -o allexport
test -f "${CONFIG}" && source "${CONFIG}"
set +o allexport

set +o errexit
read -r -d '' CAPTURE_MODES <<'EOMODES'
  [PNG] Region
  [PNG] Screen
  [PNG] Window
  [GIF] Region
  [GIF] Screen
  [GIF] Window
  [MP4] Region
  [MP4] Screen
  [MP4] Window
EOMODES
set -o errexit
LINES=$(($(printf "${CAPTURE_MODES}" | wc -l) + 1))
# }}}

countdown () { # <seconds:int:3> -> Void {{{
  _seconds="${1:-3}"

  while test "${_seconds}" -gt "0"; do
    notify-send "Screenshot" "Recording in ${_seconds} seconds" -t 1000
    sleep 1
    (( _seconds=${_seconds}-1 ))
  done
} # }}}

check_deps () { # <dependencies:@string> -> Void {{{
  _deps=${@}
  _missing=""
  for _dep in ${_deps}; do
    if ! hash "${_dep}" 2>/dev/null; then
      _missing="${_missing} ${_dep}"
    fi
  done
  if test -n "${_missing}"; then
    printf "Missing required dependencies:${_missing}\n"
  fi
} # }}}

ffmpeg () { # Helper function -> `ffmpeg` {{{
    command ffmpeg -hide_banner -loglevel error -nostdin "${@}"
} # }}}

video_to_gif () { # <tmpfile:path> -> Void {{{
  ffmpeg -i "${1}" -vf palettegen -f image2 -c:v png - |
  ffmpeg -i "${1}" -i - -filter_complex paletteuse "${1}.gif"
  rm "${1}"
  mv "${1}.gif" "${1}"
} #  }}}

# Argument parsing {{{
capture_mode="selection"
positional=()
while test "${#}" -gt "0"; do
  case "${1}" in
    -m|--monitor) # {{{
      capture_mode="monitor"
      shift;; # }}}
    -w|--window) # {{{
      capture_mode="window"
      shift;; # }}}
    -s|--selection) # {{{
      capture_mode="selection"
      shift;shift;; # }}}
    -c|--countdown) # {{{
      COUNTDOWN="${2}"
      shift;shift;; # }}}
    --*) # {{{
      printf "Unknown option: ${1}\n"
      exit 1
      shift;;
    -*)
      shopts="${1}"
      if test "${#shopts}" -le "2"; then
        printf "Unknown option: ${shopts}\n"
        exit 2
      fi
      shift
      set -- "${shopts:0:2}" "-${shopts:2}" "${@}"
      ;;
    *)
      positional+=("${1}")
      shift;; # }}}
  esac
done
set -- "${positional[@]}"

if test "${#}" -gt "0"; then
  if test "${1}" = "stop"; then
    pkill -fxn '(/\S+)*ffmpeg\s.*\sx11grab\s.*'
    exit 0
  fi
fi
# }}}

check_deps rofi ffcast xclip slop sharenix
if test ! -d "${SCREENSHOT_DIRECTORY}"; then
  mkdir -p "$(realpath "${SCREENSHOT_DIRECTORY}")"
fi

main () {
  CHOICE="$( printf "${CAPTURE_MODES}" | rofi -lines "${LINES}" -dmenu -i -fuzzy -p "Screenshot" )"

  # Temporary file handling {{{
  # create temporary file
  tmpfile="$(mktemp /tmp/screenshot-XXXXXX)"

  # create file descriptor 3 for writing to a temporary file so that
  # echo ... >&3 writes to that file
  exec 3>"${tmpfile}"

  # create file descriptor 4 for reading from the same file so that
  # the file seek positions for reading and writing can be different
  exec 4<"${tmpfile}"

  # delete temp file; the directory entry is deleted at once; the reference counter
  # of the inode is decremented only after the file descriptor has been closed.
  # The file content blocks are deallocated (this is the real deletion) when the
  # reference counter drops to zero.
  rm "${tmpfile}"

  # close the file descriptor
  trap "exec 3>-" RETURN
  # }}}

  NOW="$(date '+%d-%m-%Y %H:%M:%S')"

  # FIXME: Why use slop when `ffcast -s` exists?
  #        The selection looks better I guess... auto select window?
  #        Does that mean window is unnecessary?
  EXTENSION=""
  case "${CHOICE}" in
    '  [PNG] Region') EXTENSION=".png"
      notify-send "Screenshot" "Select a region to capture" -t 2500
      ffcast -q "$(slop -n -f '-g %g ')" png "${tmpfile}"
      ;;
    '  [PNG] Screen') EXTENSION=".png"
      ffcast -q png "${tmpfile}"
      ;;
    '  [PNG] Window') EXTENSION=".png"
      ffcast -q png -w "${tmpfile}"
      ;;
    '  [GIF] Region') EXTENSION=".gif"
      notify-send "Screenshot" "Select a region to record" -t 2500
      ffcast -q "$(slop -n -f '-g %g ' && countdown)" rec "${tmpfile}.mp4"
      notify-send "Screenshot" "Converting MP4 to GIF...\n(this can take a while)" -t 2500
      video_to_gif "${tmpfile}.mp4"
      ;;
    '  [GIF] Screen');;
    '  [GIF] Window');;
    '  [MP4] Region');;
    '  [MP4] Screen');;
    '  [MP4] Window');;
    *) exit 1;;
  esac

  # Post-procedure: File
  cp "${tmpfile}" "$(realpath "${SCREENSHOT_DIRECTORY}/Screenshot-${NOW}${EXTENSION}")"
  notify-send "Screenshot" "${CHOICE} saved to ${SCREENSHOT_DIRECTORY}" -t 1500

  # Post-procedure: Clipboard
  # TODO: Consider making this a file object from the File procedure, or the tmpfile
  #xclip -selection clipboard -t image/png "${tmpfile}"
  #notify-send "Screenshot" "${CHOICE} copied to Clipboard" -t 1500

  # TODO: Post-procedure: Sharenix upload
  # sharenix -n -c

  # Finish
  rm "${tmpfile}"
}
main &
