#!/usr/bin/env bash
set -euo pipefail

# TODO $1 daemon -> refresh some settings more often than polybar would
# TODO   daemonize undim-task and lock further processing of that part https://stackoverflow.com/a/1715151
# FIXME notify-send from crontab
# TODO Become hostile towards xfce4-power-man and xfce4-screensav
# TODO args (debug, polybar)
# ??? Use xset dpms force standby for turning off screen?

# This script is intended to be scheduled by cron or polybar.

# */5 * * * * /bin/bash /path/to/power-man

DEBUG="${1:+1}"

# NB! Decimals are delimited by a comma, *not* a period, and they're a bit funky
# TODO Don't pass global variables to functions? Or do? More maintainable
: "${DIM_AFTER:=5}"
: "${DIM_LEVEL:=40}"
: "${LOCK_AFTER:=10}"
: "${LOCK_COMMAND:=betterlockscreen --lock dimblur --blur 8}"
: "${LOCK_PROCESS:=i3lock}"
: "${SUSPEND_AFTER:=20}"
: "${SUSPEND_METHOD:=suspend}" # suspend / hibernate
: "${WARN_PERCENTAGE:=15}"
: "${WARN_MINUTES:=15}"
: "${FULL_THRESHOLD:=95}"
: "${LOCKDIR:=/tmp/power-man-lock}"

pm::utils::check_deps () { # <dependencies:@String> -> Void {{{
  local -r _deps=${@}
  local _missing=""
  # Could also shift instead
  for _dep in ${_deps}; do
    if ! hash "${_dep}" 2>/dev/null; then
      _missing="${_missing} ${_dep}"
    fi
  done
  if test -n "${_missing}"; then
    notify-send "power-man" "Missing required dependencies:${_missing}\n"
    printf "Missing required dependencies:${_missing}\n"
    exit 1
  fi
} # }}}

pm::utils::procgrep () { # <process_name:String> -> Void {{{
  local -r _process="${1}"
  # This is, AFAIK, the only clean way of actually detect a running process from a program name.
  #   `pgrep -fl`: pgrep for -full process names (not just first 15 chars) and -list the process names as well
  #   `printf "${1}" | awk '{print $1}'`: using the first argument passed to the script
  #   `awk '{print $2}'`: remove the PIDs so you're left with the process names
  #   `grep "$(printf "${1}" | awk '{print $1}' | head -c 15)"`: grep for the process name passed to the script (first 15 chars) in case the script is open in vim or other program has similar name
  if test -z "$(pgrep -fl "$(printf "${_process}" \
              | awk '{print $1}')" \
              | awk '{print $2}' \
              | grep "$(printf "${_process}" \
              | awk '{print $1}' \
              | head -c 15)")"; then
    return 1
  fi
  return 0
} # }}}

pm::utils::float2int () { # <float:@Number> -> Int {{{
  local -r _float="$(printf '%s\n' "${@}" | sed -r 's/[.]+/,/g' | sed -r 's/[ ]+//g')"

  awk 'BEGIN{for (i=1; i<ARGC;i++)
   printf "%.0f\n", ARGV[i]}' "${_float}"
} # }}}

pm::utils::uq () { # <data|String> <key:String> -> String {{{
  # jq for upower-syntax
  local -r _data="$(</dev/stdin)"
  local -r _key="${1}"

  printf '%s\n' "${_data}" \
    | grep -E "${_key}" \
    | sed -E "s/^\s*${_key}\s+//"
} # }}}

pm::polybarpp () { # <percentage:Int> -> Void {{{
  # https://github.com/polybar/polybar/wiki/Formatting#foreground-color-f
  local -r _battery_level="$(pm::utils::float2int "${1:?}")"
  local -r _low_threshold="$(pm::utils::float2int "${2:?}")"
  local -r _full_threshold="$(pm::utils::float2int "${3:?}")"
  local -r _battery_state="${4:?}"

  local -r _icon_urgent=' '
  local -r _icon_charging=' '
  local -r _icon_discharging=' '
  local -r _icon_full=' '
  local -r _color_urgent='%{F#E27878}'
  local -r _color_charging=''
  local -r _color_discharging=''
  local -r _color_full='%{F#A3BE8C}'

  local _icon=""
  local _color=""
  if test "${_battery_level}" -le "${_low_threshold}"; then
    readonly _icon="${_icon_discharging}"
    readonly _color="${_color_urgent}"
  elif test "${_battery_level}" -ge "${_full_threshold}"; then
    readonly _icon="${_icon_full}"
    readonly _color="${_color_full}"
  elif test "${_battery_state}" = "charging"; then
    readonly _icon="${_icon_charging}"
    readonly _color="${_color_charging}"
  else
    readonly _icon="${_icon_discharging}"
    readonly _color="${_color_discharging}"
  fi

  printf '%s\n' "${_color}${_icon}${_battery_level}%"
} # }}}

pm::battery () { # <warn_percentage:Int> -> String {{{
  local -r _warn_percentage="$(pm::utils::float2int "${1:-15}")"
  local -r _warn_minutes="$(pm::utils::float2int "${2:-15}")"
  local -r _full_threshold="$(pm::utils::float2int "${3:-95}")"

  # TODO sleep if battery very low?
  # TODO Notify when battery at normal levels

  # local -r _battery_info="$(acpi -b | head -1)"
  # local -r _battery_level="$(printf '%s\n' "${_battery_info}" | grep -P -o '[0-9]+(?=%)')"
  # local -r _battery_state="$(printf '%s\n' "${_battery_info}" | awk '{print $3}' | tr -d ',')"
  # local -r _battery_time="$(printf '%s\n' "${_battery_info}" | awk '{print $5}')"

  # upower seems to update rather weirdly
  local -r _battery_path="$(upower -e | grep 'battery')"
  local -r _battery_info="$(upower -i "${_battery_path}")"
  local -r _battery_level="$(printf '%s\n' "${_battery_info}" | pm::utils::uq 'percentage:' | sed -r 's/[%]+//g')"
  local -r _battery_state="$(printf '%s\n' "${_battery_info}" | pm::utils::uq 'state:')"
  local -r _battery_time="$(printf '%s\n' "${_battery_info}" | pm::utils::uq 'time to .+:')"
  local -r _battery_time_int="$(pm::utils::float2int "$(printf '%s\n' "${_battery_time}" | awk '{print $1}')")"
  local -r _battery_time_unit="$(printf '%s\n' "${_battery_time}" | awk '{print $2}')"
  # Alternative to _battery_state
  # local -r _line_path="$(upower -e | grep line_power)"
  # local -r _line_charging="$(upower -i "${_line_path}" | grep -A2 'line-power' | grep online | awk '{print $2}')"

  pm::polybarpp "${_battery_level}" "${_warn_percentage}" "${_full_threshold}" "${_battery_state}"

  # TODO Only send one notif
  # if test "${_battery_status}" = "Discharging" \
  #    && ( test "${_battery_level}" -le "${_warn_battery_remaining_percentage}" \
  #      || [[ "${_battery_time}"  <  "${_warn_battery_remaining_time}" ]] ); then
  if test "${_battery_state}" = "discharging" \
     && ( test "${_battery_level}" -le "${_warn_percentage}" \
       || ( test "${_battery_time_int}" -le "${_warn_minutes}" -a "${_battery_time_unit}" = "minutes" ) ); then
    DISPLAY=:0 notify-send -u critical --hint int:transient:1 "Battery low!" "Battery level is ${_battery_level}%, you have ${_battery_time} left"
  fi
} # }}}

pm::utils::cleanup () { # {{{
  if ! rmdir "${LOCKDIR:?}" >/dev/null 2>&1; then
    test "${DEBUG}" = "1" && printf "[PM] Failed to remove lock directory\n"
    # Failed to remove lock directory
    exit 1
  fi
} # }}}

pm::utils::daemonize () { # {{{
  # TODO https://stackoverflow.com/a/169969
  # me="$(basename "$0")";
  # running=$(ps h -C "$me" | grep -wv $$ | wc -l);
  # [[ $running > 1 ]] && exit;
  if ! mkdir "${LOCKDIR}" >/dev/null 2>&1; then
    # Couldn't acquire lock
    test "${DEBUG}" = "1" && printf "[PM] Couldn't acquire lock\n"
    exit 1
  fi
  # Acquired lock
  trap "pm::utils::cleanup" EXIT

  while true; do
    if ! test -d "${LOCKDIR}"; then
      # Run until no lockdir is found;
      #   rmdir "${LOCKDIR}" >/dev/null 2>&1
      exit 0
    fi
    sleep 5
    power-man
  done
} # }}}

pm::screensaver () { # <dim_after:Number> <dim_level:Number> <lock_after:Number> <lock_command:String> <lock_process:String> <suspend_after:Number> <suspend_method:String[sleep|hibernate]> -> Void {{{
  local -r _dim_after="$(pm::utils::float2int "$((${1:-5} * 60000))")"
  local -r _dim_level="$(pm::utils::float2int "${2:-40}")"
  local -r _lock_after="$(pm::utils::float2int "$((${3:-15} * 60000))")"
  local -r _lock_command="${4:-betterlockscreen --lock dimblur --blur 8}"
  local -r _lock_base="$(printf '%s\n' "${_lock_command}" | awk '{print $1}')"
  local -r _lock_args=$(printf '%s\n' "${_lock_command}" | cut -f 2- -d ' ')
  local -r _lock_process="${5}"
  local -r _suspend_after="$(pm::utils::float2int "$((${6:-20} * 60000))")"
  local -r _suspend_method="${7:-suspend}"
  local -r _idle_time="$(xprintidle)"

  if test -f /tmp/power-man-backlight.dat \
       -a "${_idle_time}" -le "${_dim_after}"; then
    test "${DEBUG}" = "1" && printf '[PM] Restoring monitor brightness\n'
    xbacklight -set "$(cat /tmp/power-man-backlight.dat)"
    rm -f /tmp/power-man-backlight.dat
    rmdir "${LOCKDIR}" >/dev/null 2>&1
  fi

  if test ! -f /tmp/power-man-backlight.dat \
       -a "${_idle_time}" -gt "${_dim_after}" \
       -a "${_dim_after}" -ne "0"; then
    test "${DEBUG}" = "1" && printf '[PM] Dimming monitor\n'
    printf '%s\n' "$(pm::utils::float2int "$(xbacklight -get)")" > /tmp/power-man-backlight.dat
    xbacklight -set "${_dim_level}"
    pm::utils::daemonize
  fi

  if ! pm::utils::procgrep "${_lock_process}" \
     && test "${_idle_time}" -gt "${_lock_after}" \
          -a "${_lock_after}" -ne "0"; then
    test "${DEBUG}" = "1" && printf '[PM] Locking screen\n'
    command "${_lock_base}" ${_lock_args} &
  fi

  if test "${_idle_time}" -gt "${_suspend_after}" \
       -a "${_suspend_after}" -ne "0"; then
    test "${DEBUG}" = "1" && printf '[PM] Suspending system\n'
    systemctl "${_suspend_method}"
  fi
} # }}}

main () { # -> Void {{{
  pm::utils::check_deps xprintidle xbacklight upower # acpi
  pm::battery "${WARN_PERCENTAGE:-}" "${WARN_MINUTES:-}" "${FULL_THRESHOLD:-}"
  pm::screensaver "${DIM_AFTER:-}" "${DIM_LEVEL:-}" "${LOCK_AFTER:-}" "${LOCK_COMMAND:-}" "${LOCK_PROCESS:-}" "${SUSPEND_AFTER:-}" "${SUSPEND_METHOD:-}"
} # }}}
main
