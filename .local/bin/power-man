#!/usr/bin/env bash
set -euo pipefail

# TODO $1 daemon -> refresh some settings more often than polybar would

# NB! Decimals are delimited by a comma, *not* a period
: "${DIM_AFTER:=5}"
: "${DIM_LEVEL:=40}"
: "${LOCK_AFTER:=10}"
: "${LOCK_COMMAND:=betterlockscreen --lock dimblur --blur 8}"
: "${SUSPEND_AFTER:=20}"
: "${SUSPEND_METHOD:=sleep}"
: "${WARN_PERCENTAGE:=15}"
: "${WARN_TIME:=00:15:00}"

pm::util::check_deps () { # <dependencies:@String> -> Void {{{
  local -r _deps=${@}
  local _missing=""
  # Could also shift instead
  for _dep in ${_deps}; do
    if ! hash "${_dep}" 2>/dev/null; then
      _missing="${_missing} ${_dep}"
    fi
  done
  if test -n "${_missing}"; then
    notify-send "power-man" "Missing required dependencies:${_missing}\n"
    printf "Missing required dependencies:${_missing}\n"
    exit 1
  fi
} # }}}

pm::util::procgrep () { # <process_name:String> -> Void {{{
  local -r _process="${1}"
  # This is, AFAIK, the only clean way of actually detect a running process from a program name.
  #   `pgrep -fl`: pgrep for -full process names (not just first 15 chars) and -list the process names as well
  #   `printf "${1}" | awk '{print $1}'`: using the first argument passed to the script
  #   `awk '{print $2}'`: remove the PIDs so you're left with the process names
  #   `grep "$(printf "${1}" | awk '{print $1}' | head -c 15)"`: grep for the process name passed to the script (first 15 chars) in case the script is open in vim or other program has similar name
  if test -z "$(pgrep -fl "$(printf "${_process}" \
              | awk '{print $1}')" \
              | awk '{print $2}' \
              | grep "$(printf "${_process}" \
              | awk '{print $1}' \
              | head -c 15)")"; then
    return 1
  fi
  return 0
} # }}}

pm::util::float2int () { # <float:@Number> -> Int {{{
  local -r _float="$(printf '%s\n' "${@}" | sed -r 's/[.]+/,/g' | sed -r 's/[ ]+//g')"

  awk 'BEGIN{for (i=1; i<ARGC;i++)
   printf "%.0f\n", ARGV[i]}' "${_float}"
} # }}}

pm::polybarpp () { # -> Void {{{
  : # TODO https://github.com/polybar/polybar/wiki/Formatting#foreground-color-f
} # }}}

pm::warn () { # <warn_percentage:Int> <warn_time:String> -> String {{{
  local -r _warn_battery_remaining_percentage="${1:-15}"
  local -r _warn_battery_remaining_time="${2:-00:15:00}"

  # Battery 0: Discharging/Charging/Not charging, 38%, 23:42:36 remaining/until charged
  local -r _battery_info="$(acpi -b)"
  # Charging, Not charging, Discharging
  local -r _battery_status="$(printf '%s\n' "${_battery_info}" | awk '{print $3}' | tr -d ',')"
  # 00:32:29
  local -r _battery_time="$(printf '%s\n' "${_battery_info}" | awk '{print $5}')"
  # 0-100
  local -r _battery_level="$(printf '%s\n' "${_battery_info}" | grep -P -o '[0-9]+(?=%)')"

  # TODO Polybar colors, own function
  printf '%s\n' "${_battery_level}%"

  # TODO Only send one notif
  if test "${_battery_status}" = "Discharging" \
     && ( \
       test "${_battery_level}" -le "${_warn_battery_remaining_percentage}" \
       || [[ "${_battery_time}"  <  "${_warn_battery_remaining_time}" ]] \
    ); then
    DISPLAY=:0 notify-send -u critical --hint int:transient:1 "Battery low!" "Battery level is ${_battery_level}%, you have ${_battery_time} left"
  fi
} # }}}

pm::screensaver () { # <dim_after:Number> <dim_level:Number> <lock_after:Number> <lock_command:String> <suspend_after:Number> <suspend_method:String[sleep|hibernate]> -> Void {{{
  local -r _dim_after="$(pm::util::float2int "$((${1:-5} * 60000))")"
  local -r _dim_level="$(pm::util::float2int "${2:-40}")"
  local -r _lock_after="$(pm::util::float2int "$((${3:-15} * 60000))")"
  local -r _lock_command="${4:-betterlockscreen --lock dimblur --blur 8}"
  local -r _lock_base="$(printf '%s\n' "${_lock_command}" | awk '{print $1}')"
  local -r _lock_args=$(printf '%s\n' "${_lock_command}" | cut -f 2- -d ' ')
  local -r _suspend_after="$(pm::util::float2int "$((${5:-20} * 60000))")"
  local -r _suspend_method="${6:-sleep}"
  local -r _idle_time="$(xprintidle)"

  echo $_idle_time
  echo $_dim_after

  if test ! -f /tmp/power-man-backlight.dat \
       -a "${_idle_time}" -gt "${_dim_after}"; then
    # mktemp "/tmp/power-man-backlight.dat"
    printf '%s\n' "$(pm::util::float2int "$(xbacklight -get)")" > /tmp/power-man-backlight.dat
    xbacklight -set "${_dim_level}"
  fi

  if test -f /tmp/power-man-backlight.dat \
       -a "${_idle_time}" -le "${_dim_after}"; then
     xbacklight -set "$(cat /tmp/power-man-backlight.dat)"
     rm -f /tmp/power-man-backlight.dat
  fi

  if ! pm::util::procgrep "${_lock_base}" \
    && test "${_idle_time}" -gt "${_lock_after}"; then
    command "${_lock_base}" ${_lock_args} &
  fi

  # TODO Test if _suspend_after is 0 and skip if it is
  if test "${_idle_time}" -gt "${_suspend_after}"; then
    systemctl "${_suspend_method}"
  fi
} # }}}

main () { # -> Void {{{
  pm::util::check_deps xprintidle acpi xbacklight
  pm::warn "${WARN_PERCENTAGE:-}" "${WARN_TIME:-}"
  pm::screensaver "${DIM_AFTER:-}" "${DIM_LEVEL:-}" "${LOCK_AFTER:-}" "${LOCK_COMMAND:-}" "${SUSPEND_AFTER:-}" "${SUSPEND_METHOD:-}"
} # }}}
main