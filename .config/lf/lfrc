# Basic Settings
set previewer ~/.config/lf/lfpreview
set hidden true
#set color256 true
set drawbox true
set icons true
set ignorecase true
set number true
set relativenumber true
set scrolloff 4
set ratios 2:3:5

set shell bash
#set shellopts '-eu'
#set ifs "\n"

map m
map o
map n
map "'"
map '"'
map d
map c
map e
map f
map q

map <esc> quit
map q quit

map cfg $${EDITOR} "${XDG_CONFIG_HOME:-${HOME}/.config}/lf/lfrc"

cmd open ${{
  case $(file --mime-type "${f}" -bL) in
    text/*|application/json) ${EDITOR} "${f}";;
    video/*|image/*/application/pdf) xdg-open "${f}" & disown;;
    *) xdg-open "${f}";;
  esac
}}
map <enter> open

cmd mkdir ${{
  printf "Directory name: "
  read dir
  mkdir "${dir}"
}}
map md mkdir

cmd mkfile ${{
  printf "File name: "
  read file
  touch "${file}"
  #${EDITOR} "${file}"
}}
map mf mkfile

cmd chmod ${{
  printf "Mode Bits: "
  read bits

  for file in "${fx}"; do
    chmod "${bits}" "${file}"
  done
}}
map ch. chmod

cmd chexec %chmod +x "${f}"
map chx chexec

cmd setbg ${{
  convert "${f}" ~/.config/wall.jpg
  feh --bg-scale ~/.config/wall.jpg
}}
map bg setbg

cmd dragon ${{
  files=()
  while IFS= read -r line; do
    files+=("${line}")
  done <<< "$fx"
  dragon-drag-and-drop -a -x "${files[@]}"
}}
map dr dragon

# Archive bindings
cmd unarchive ${{
  case "${f}" in
    *.zip) unzip "${f}";;
    *.tar.gz) tar -xzvf "${f}";;
    *.tar.bz2) tar -xjvf "${f}";;
    *.tar) tar -xvf "${f}";;
    *) printf "Unsupported format\n";;
  esac
}}
map au unarchive

cmd zip %zip -r "${f}" "${f}"
map az zip
cmd tar %tar cvf "${f}.tar" "${f}"
map at tar
cmd targz %tar cvzf "${f}.tar.gz" "${f}"
map ag targz
cmd tarbz2 %tar cjvf "${f}.tar.bz2" "${f}"
map ab tarbz2

cmd trash ${{
  files=$(printf "$fx" | tr '\n' ';')
  while test "${files}"; do
    # extract the substring from start of string up to delimiter.
    # this is the first "element" of the string.
    file=${files%%;*}

    trash-put "$(basename "${file}")"
    # if there's only one element left, set `files` to an empty string.
    # this causes us to exit this `while` loop.
    # else, we delete the first "element" of the string from files, and move onto the next.
    if test "${files}" = "${file}"; then
      files=''
    else
      files="${files#*;}"
    fi
  done
}}
map dd trash

cmd trash-list $trash-list; read trash
map tl trash-list
map trash-empty %trash-empty
map tc trash-empty
cmd trash-restore $trash-restore "$(trash-list | fzf | cut -d' ' -f3)"
map tr trash-restore

map e $${EDITOR} "${f}"
#map <right> $${EDITOR} "${f}"
map z $zathura "${f}" &

map sh set hidden!
#map dd delete
map p paste
map x cut
map y copy
map r rename
map H top
map L bottom
map R reload

map gg top
map G bottom

# Requires bash (not sh) to be set as the shell in lf
#cmd mark-add ${{
#  # querying mark
#  read -e -p "Mark as: " -n 1 markchar
#  test -z "${markchar}" && exit 0
#  markfile="${XDG_CONFIG_HOME:-${HOME}/.config}/lf/marks"
#  location="$(pwd)"
#
#  # removing old mark (from character and path)
#  if test -f "${markfile}"; then
#    sed -i "\|^${markchar} .*$|d" "${markfile}"
#    sed -i "\|^.* ${location}$|d" "${markfile}"
#  else
#    mkdir -p "$(dirname "$(realpath ${markfile})")"
#    touch "$(realpath ${markfile})"
#  fi
#  test "${markchar}" = "-" && exit 0
#
#  # adding new mark
#  tmpfile="$(mktemp ${TMPDIR:-/tmp/}lfmark.XXXXXX)"
#  exec 3> "${tmpfile}" # Open &3 for writing
#  exec 4< "${tmpfile}" # Open &4 for reading
#  rm "${tmpfile}"
#
#  { cat "${markfile}" 2>/dev/null;
#    printf "${markchar}" "${location}\n";
#  } | sort >&3
#  cat <&4 > "${markfile}"
#}}
#map m mark-add
map bm $marker add "$(pwd)"

#cmd mark-go ${{
#  FZF="${1:-}"
#  markfile="${XDG_CONFIG_HOME:-${HOME}/.config}/lf/marks"
#
#  test ! -f "${markfile}" && exit 1
#
#  # Remove recent dir if you're currently at it
#  sed -i "\|^' $(pwd)$|d" "${markfile}"
#
#  if test -n "${FZF}"; then
#    markdirs="$(sed 's/^. //' "${markfile}" 2>/dev/null)"
#    markstring="$(printf "${markdirs}\n" | fzf --preview 'ls {}')"
#    markchar="$(cat ${markfile} | grep "${markstring}$" | cut -d' ' -f1)"
#  else
#    printf "Marks:\n"
#    # Add two spaces in front of every line
#    sed 's/^/  /' "${markfile}" 2>/dev/null
#    # Querying mark
#    read -e -p "Go to mark: " -n 1 markchar
#  fi
#  test -z "${markchar}" && exit 0
#  dir=$(grep -e "^${markchar}" < "${markfile}" | cut -d' ' -f2)
#
#  # setting last visited dir
#  sed -i "/^' .*$/d" "${markfile}"
#  printf "' $(pwd)\n$(cat ${markfile})\n" > "${markfile}"
#
#  # going to wanted dir
#  test -n "${dir}" && lf -remote "send ${id} cd ${dir}"
#}}
map "'" $ "$(marker get)"
#map "'" mark-go fzf
#map '"' mark-go

map gtr cd ~/.local/share/Trash/files
map gp cd ~/Pictures
map gb cd ~/.local/bin
map gdl cd ~/Downloads
map gda cd ~/data
map gdc cd ~/Documents
map gdr cd ~/Documents/drive
map gc cd ~/.config
