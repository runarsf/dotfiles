#!/usr/bin/env bash
set -euo pipefail

bspcfg::core::argparse () { # <positionals_nameref> <@args> {{{
  # Requires bash >=4.3
  local -n _nameref="${1}"
  _nameref=()
  shift
  set -- "${@}"

  while test "${#}" -gt "0"; do
    case "${1}" in
      (--*) # {{{
        printf "Unknown option: ${1}\n"
        exit 1
        shift;;
      (-*)
        # FIXME Make posix
        shopts="${1}"
        if test "${#shopts}" -le "2"; then
          printf "Unknown option: ${shopts}\n"
          exit 2
        fi
        shift
        set -- "${shopts:0:2}" "-${shopts:2}" "${@}"
        ;;
      (*)
        _nameref+=("$(printf '%s\n' "${1}" | tr '[:upper:]' '[:lower:]')")
        shift;; # }}}
    esac
  done
} # }}}

bspcfg::utils::check_deps () { # <dependencies:*string> -> Void {{{
  local _deps=${@}
  local _missing=""
  for _dep in ${_deps}; do
    if ! hash "${_dep}" 2>/dev/null; then
      _missing="${_missing} ${_dep}"
    fi
  done
  if test -n "${_missing}"; then
    printf "Missing required dependencies:${_missing}\n"
    notify-send "$(basename "${0}")" "Missing required dependencies:${_missing}"
    exit 1
  fi
} # }}}

bspcfg::cmd::focus () { # {{{
  # TODO utils-function for checking how many args a function requires
  test "${#}" -eq "1" || { printf "'focus' requires exactly 1 argument, but ${#} were given...\n"; exit 1; }

  local -r _motion="${1}"
  #layout="$(bspc query -T -d | jq --raw-output '.layout')"
  local _layout=""
  bspc query -T -d | grep '"layout":"monocle"' \
    && readonly _layout="monocle"

  case "${_layout}:${_motion}" in
    monocle:north|monocle:east) bspc node --focus next.local.\!hidden.window;;
    monocle:south|monocle:west) bspc node --focus prev.local.\!hidden.window;;
    *) bspc node --focus "${_motion}" || bspc monitor --focus "${_motion}";;
  esac
} # }}}

bspcfg::cmd::scratchpad () { # {{{
  local -r _class="${1:-scratchpad}"
  local -r _terminal_cmd="${2:-${TERMINAL} --class ${_class} --title scratchpad}"
  local -r _size="${3:-1600x1000+0+0}"
  local -r _sticky="${4:-on}"
  local -r _state="${5:-floating}"
  local -r _center="${6:-true}"

  bspcfg::utils::check_deps xdo xprop awk

  local -r _id="$(xdo id -n ${_class} | head -1)"
  if test -z "${_id}"; then
    bspc rule -r "*:${_class}"
    bspc rule -a "*:${_class}" sticky="${_sticky}" state="${_state}" center="${_center}" rectangle="${_size}"
    eval "${_terminal_cmd}" &
    # Sleep until window has started
    until test ! -z $(xdo id -n ${_class} | head -1); do
      sleep 0.5
    done
    sleep 0.5
    # Position and size should be up to the user
    bspc rule -r "*:${_class}"
    bspc rule -a "*:${_class}" sticky="${_sticky}" state="${_state}"
  else
    local _action='hide'
    if test "$(xprop -id ${_id} | awk '/window state: / {print $3}')" = 'Withdrawn'; then
      _action='show'
    fi
    xdo "${_action}" -n "${_class}"
  fi
} # }}}

bspcfg::cmd::dynws () { # {{{
  for i in $(bspc query -D -d '.!focused.!occupied' --names); do
    bspc desktop "${i}" -r
  done
} # }}}

bspcfg::main () { # <@args> {{{
  local -r ARGS=("${@}")

  : "${DISPLAY:?X server doesn\'t seem to be running...}"

  bspcfg::utils::check_deps bspc

  local POSITIONALS
  bspcfg::core::argparse POSITIONALS "${ARGS[@]}"
  # declare -p POSITIONALS
  : "${POSITIONALS:?No commands provided...}"

  if test "$(type -t "bspcfg::cmd::${POSITIONALS[0]}")" = "function"; then
    "bspcfg::cmd::${POSITIONALS[0]}" "${POSITIONALS[@]:1}"
  else
    printf '%s\n' "Unknown command '${POSITIONALS[0]}'..."
    exit 1
  fi
} # }}}
bspcfg::main "${@}"
